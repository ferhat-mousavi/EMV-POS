// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "VirtualPOS.h"
#include "InfoFrame.h"
#include "TransactionView.h"
#include "VirtualPosSetting.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif





#include "scardreadermanager.h"
#include "SmartCardReader.h"
#include "scrhelper.h"
#include "Des.h"

#include "PinPad.h"
#include "InputAmount.h"
#include ".\mainfrm.h"


#define VISA_CA_TEST_PUBLIC_KEYS
#define VISA_CA_PRODUCTION_PUBLIC_KEY

#ifdef VISA_CA_TEST_PUBLIC_KEYS 

static const BYTE PubKeyMod95[256] = {
0xBE, 0x9E, 0x1F, 0xA5, 0xE9, 0xA8, 0x03, 0x85, 0x29, 0x99, 0xC4, 0xAB, 0x43, 0x2D, 0xB2, 0x86, 
0x00, 0xDC, 0xD9, 0xDA, 0xB7, 0x6D, 0xFA, 0xAA, 0x47, 0x35, 0x5A, 0x0F, 0xE3, 0x7B, 0x15, 0x08, 
0xAC, 0x6B, 0xF3, 0x88, 0x60, 0xD3, 0xC6, 0xC2, 0xE5, 0xB1, 0x2A, 0x3C, 0xAA, 0xF2, 0xA7, 0x00, 
0x5A, 0x72, 0x41, 0xEB, 0xAA, 0x77, 0x71, 0x11, 0x2C, 0x74, 0xCF, 0x9A, 0x06, 0x34, 0x65, 0x2F, 
0xBC, 0xA0, 0xE5, 0x98, 0x0C, 0x54, 0xA6, 0x47, 0x61, 0xEA, 0x10, 0x1A, 0x11, 0x4E, 0x0F, 0x0B, 
0x55, 0x72, 0xAD, 0xD5, 0x7D, 0x01, 0x0B, 0x7C, 0x9C, 0x88, 0x7E, 0x10, 0x4C, 0xA4, 0xEE, 0x12,
0x72, 0xDA, 0x66, 0xD9, 0x97, 0xB9, 0xA9, 0x0B, 0x5A, 0x6D, 0x62, 0x4A, 0xB6, 0xC5, 0x7E, 0x73,
0xC8, 0xF9, 0x19, 0x00, 0x0E, 0xB5, 0xF6, 0x84, 0x89, 0x8E, 0xF8, 0xC3, 0xDB, 0xEF, 0xB3, 0x30,
0xC6, 0x26, 0x60, 0xBE, 0xD8, 0x8E, 0xA7, 0x8E, 0x90, 0x9A, 0xFF, 0x05, 0xF6, 0xDA, 0x62, 0x7B
};

static const BYTE PubKeyExp95[3] = {3};

static const BYTE PubKeyIndex95 = 0x95;


static const BYTE PubKeyMod96[256] = {
0xB7, 0x45, 0x86, 0xD1, 0x9A, 0x20, 0x7B, 0xE6, 0x62, 0x7C, 0x5B, 0x0A, 0xAF, 0xBC, 0x44, 0xA2, 
0xEC, 0xF5, 0xA2, 0x94, 0x2D, 0x3A, 0x26, 0xCE, 0x19, 0xC4, 0xFF, 0xAE, 0xEE, 0x92, 0x05, 0x21, 
0x86, 0x89, 0x22, 0xE8, 0x93, 0xE7, 0x83, 0x82, 0x25, 0xA3, 0x94, 0x7A, 0x26, 0x14, 0x79, 0x6F, 
0xB2, 0xC0, 0x62, 0x8C, 0xE8, 0xC1, 0x1E, 0x38, 0x25, 0xA5, 0x6D, 0x3B, 0x1B, 0xBA, 0xEF, 0x78, 
0x3A, 0x5C, 0x6A, 0x81, 0xF3, 0x6F, 0x86, 0x25, 0x39, 0x51, 0x26, 0xFA, 0x98, 0x3C, 0x52, 0x16,
0xD3, 0x16, 0x6D, 0x48, 0xAC, 0xDE, 0x8A, 0x43, 0x12, 0x12, 0xFF, 0x76, 0x3A, 0x7F, 0x79, 0xD9, 
0xED, 0xB7, 0xFE, 0xD7, 0x6B, 0x48, 0x5D, 0xE4, 0x5B, 0xEB, 0x82, 0x9A, 0x3D, 0x47, 0x30, 0x84, 
0x8A, 0x36, 0x6D, 0x33, 0x24, 0xC3, 0x02, 0x70, 0x32, 0xFF, 0x8D, 0x16, 0xA1, 0xE4, 0x4D, 0x8D
};

static const BYTE PubKeyExp96[3] = {3};

static const BYTE PubKeyIndex96 = 0x96;



/*static const BYTE PubKeyMod97[128] = {
0xAF, 0x07, 0x54, 0xEA, 0xED, 0x97, 0x70, 0x43, 0xAB, 0x6F, 0x41, 0xD6, 0x31, 0x2A, 0xB1, 0xE2, 
0x2A, 0x68, 0x09, 0x17, 0x5B, 0xEB, 0x28, 0xE7, 0x0D, 0x5F, 0x99, 0xB2, 0xDF, 0x18, 0xCA, 0xE7, 
0x35, 0x19, 0x34, 0x1B, 0xBB, 0xD3, 0x27, 0xD0, 0xB8, 0xBE, 0x9D, 0x4D, 0x0E, 0x15, 0xF0, 0x7D, 
0x36, 0xEA, 0x3E, 0x3A, 0x05, 0xC8, 0x92, 0xF5, 0xB1, 0x9A, 0x3E, 0x9D, 0x34, 0x13, 0xB0, 0xD9, 
0x7E, 0x7A, 0xD1, 0x0A, 0x5F, 0x5D, 0xE8, 0xE3, 0x88, 0x60, 0xC0, 0xAD, 0x00, 0x4B, 0x1E, 0x06, 
0xF4, 0x04, 0x0C, 0x29, 0x5A, 0xCB, 0x45, 0x7A, 0x78, 0x85, 0x51, 0xB6, 0x12, 0x7C, 0x0B, 0x29,
};

static const BYTE PubKeyExp97[3] = {3};

static const BYTE PubKeyIndex97 = 0x97;*/



static const BYTE PubKeyMod98[128] = {
0xCA, 0x02, 0x6E, 0x52, 0xA6, 0x95, 0xE7, 0x2B, 0xD3, 0x0A, 0xF9, 0x28, 0x19, 0x6E, 0xED, 0xC9, 
0xFA, 0xF4, 0xA6, 0x19, 0xF2, 0x49, 0x2E, 0x3F, 0xB3, 0x11, 0x69, 0x78, 0x9C, 0x27, 0x6F, 0xFB, 
0xB7, 0xD4, 0x31, 0x16, 0x64, 0x7B, 0xA9, 0xE0 , 0xD1, 0x06, 0xA3, 0x54, 0x2E, 0x39, 0x65, 0x29, 
0x2C, 0xF7, 0x78, 0x23, 0xDD, 0x34, 0xCA, 0x8E, 0xEC, 0x7D, 0xE3, 0x67, 0xE0, 0x80, 0x70, 0x89, 
0x50, 0x77, 0xC7, 0xEF, 0xAD, 0x93, 0x99, 0x24, 0xCB, 0x18, 0x70, 0x67, 0xDB, 0xF9, 0x2C, 0xB1, 
0xE7, 0x85, 0x91, 0x7B, 0xD3, 0x8B, 0xAC, 0xE0, 0xC1, 0x94, 0xCA, 0x12, 0xDF, 0x0C, 0xE5, 0xB7, 
0xA5, 0x02, 0x75, 0xAC, 0x61, 0xBE, 0x7C, 0x3B, 0x43, 0x68, 0x87, 0xCA, 0x98, 0xC9, 0xFD, 0x39
};

static const BYTE PubKeyExp98[3] = {3};

static const BYTE PubKeyIndex98 = 0x98;


static const BYTE PubKeyMod99[128] = {
0xAB, 0x79, 0xFC, 0xC9, 0x52, 0x08, 0x96, 0x96, 0x7E, 0x77, 0x6E, 0x64, 0x44, 0x4E, 0x5D, 0xCD, 
0xD6, 0xE1, 0x36, 0x11, 0x87, 0x4F, 0x39, 0x85, 0x72, 0x25, 0x20, 0x42, 0x52, 0x95, 0xEE, 0xA4, 
0xBD, 0x0C, 0x27, 0x81, 0xDE, 0x7F, 0x31, 0xCD, 0x3D, 0x04, 0x1F, 0x56, 0x5F, 0x74, 0x73, 0x06, 
0xEE, 0xD6, 0x29, 0x54, 0xB1, 0x7E, 0xDA, 0xBA, 0x3A, 0x6C, 0x5B, 0x85, 0xA1, 0xDE, 0x1B, 0xEB, 
0x9A, 0x34, 0x14, 0x1A, 0xF3, 0x8F, 0xCF, 0x82, 0x79, 0xC9, 0xDE, 0xA0, 0xD5, 0xA6, 0x71, 0x0D, 
0x08, 0xDB, 0x41, 0x24, 0xF0, 0x41, 0x94, 0x55, 0x87, 0xE2, 0x03, 0x59, 0xBA, 0xB4, 0x7B, 0x75, 
0x75, 0xAD, 0x94, 0x26, 0x2D, 0x4B, 0x25, 0xF2, 0x64, 0xAF, 0x33, 0xDE, 0xDC, 0xF2, 0x8E, 0x09, 
0x61, 0x5E, 0x93, 0x7D, 0xE3, 0x2E, 0xDC, 0x03, 0xC5, 0x44, 0x45, 0xFE, 0x7E, 0x38, 0x27, 0x77
};


static const BYTE PubKeyExp99[3] = {3};

static const BYTE PubKeyIndex99 = 0x99;

#endif
#ifdef VISA_CA_PRODUCTION_PUBLIC_KEY // changed by Ferhat

// VISA PRODUCTION KEYS

// changed by Ferhat
/*static const BYTE PubKeyModV5[128] = {
0xD0, 0x13, 0x5C, 0xE8, 0xA4, 0x43, 0x6C, 0x7F, 0x9D, 0x5C, 0xC6, 0x65, 0x47, 0xE3, 0x0E, 0xA4, 
0x02, 0xF9, 0x81, 0x05, 0xB7, 0x17, 0x22, 0xE2, 0x4B, 0xC0, 0x8D, 0xCC, 0x80, 0xAB, 0x7E, 0x71, 
0xEC, 0x23, 0xB8, 0xCE, 0x6A, 0x1D, 0xC6, 0xAC ,0x2A, 0x8C, 0xF5, 0x55, 0x43, 0xD7, 0x4A, 0x8A, 
0xE7, 0xB3, 0x88, 0xF9, 0xB1, 0x74, 0xB7, 0xF0, 0xD7, 0x56, 0xC2, 0x2C, 0xBB, 0x59, 0x74, 0xF9, 
0x01, 0x6A, 0x56, 0xB6, 0x01, 0xCC, 0xA6, 0x4C, 0x71, 0xF0, 0x4B, 0x78, 0xE8, 0x6C, 0x50, 0x1B, 
0x19, 0x3A, 0x55, 0x56, 0xD5, 0x38, 0x9E, 0xCE, 0x4D, 0xEA, 0x25, 0x8A, 0xB9, 0x7F, 0x52, 0xA3
};

static const BYTE PubKeyExpV5[3] = {3};

static const BYTE PubKeyIndexV5 = 0x05;*/


static const BYTE PubKeyModV3[128] = {
0xB3, 0xE5, 0xE6, 0x67, 0x50, 0x6C, 0x47, 0xCA, 0xAF, 0xB1, 0x2A, 0x26, 0x33, 0x81, 0x93, 0x50, 
0x84, 0x66, 0x97, 0xDD, 0x65, 0xA7, 0x96, 0xE5, 0xCE, 0x77, 0xC5, 0x7C, 0x62, 0x6A, 0x66, 0xF7, 
0x0B, 0xB6, 0x30, 0x91, 0x16, 0x12, 0xAD, 0x28 ,0x32, 0x90, 0x9B, 0x80, 0x62, 0x29, 0x1B, 0xEC, 
0xA4, 0x6C, 0xD3, 0x3B, 0x66, 0xA6, 0xF9, 0xC9, 0xD4, 0x8C, 0xED, 0x8B, 0x4F, 0xC8, 0x56, 0x1C, 
0x8A, 0x1D, 0x8F, 0xB1, 0x58, 0x62, 0xC9, 0xEB, 0x60, 0x17, 0x8D, 0xEA, 0x2B, 0xE1, 0xF8, 0x22, 
0x36, 0xFF, 0xCF, 0xF4, 0xF3, 0x84, 0x3C, 0x27, 0x21, 0x79, 0xDC, 0xDD, 0x38, 0x4D, 0x54, 0x10,
0x53, 0xDA, 0x6A, 0x6A, 0x0D, 0x3C, 0xE4, 0x8F, 0xDC, 0x2D, 0xC4, 0xE3, 0xE0, 0xEE, 0xE1, 0x5F
};

static const BYTE PubKeyExpV3[3] = {3};

static const BYTE PubKeyIndexV3 = 0x03;

static const BYTE PubKeyModV1[128] = {
0xC6, 0x96, 0x03, 0x42, 0x13, 0xD7, 0xD8, 0x54, 0x69, 0x84, 0x57, 0x9D, 0x1D, 0x0F, 0x0E, 0xA5, 
0x19, 0xCF, 0xF8, 0xDE, 0xFF, 0xC4, 0x29, 0x35, 0x4C, 0xF3, 0xA8, 0x71, 0xA6, 0xF7, 0x18, 0x3F, 
0x12, 0x28, 0xDA, 0x5C, 0x74, 0x70, 0xC0, 0x55 ,0x38, 0x71, 0x00, 0xCB, 0x93, 0x5A, 0x71, 0x2C, 
0x4E, 0x28, 0x64, 0xDF, 0x5D, 0x64, 0xBA, 0x93, 0xFE, 0x7E, 0x63, 0xE7, 0x1F, 0x25, 0xB1, 0xE5, 
0xF5, 0x29, 0x85, 0x75, 0xEB, 0xE1, 0xC6, 0x3A, 0xA6, 0x17, 0x70, 0x69, 0x17, 0x91, 0x1D, 0xC2, 
0xA7, 0x5A, 0xC2, 0x8B, 0x25, 0x1C, 0x7E, 0xF4, 0x0F, 0x23, 0x65, 0x91, 0x24, 0x90, 0xB9, 0x39,
0xBC, 0xA2, 0x12, 0x4A, 0x30, 0xA2, 0x8F, 0x54, 0x40, 0x2C, 0x34, 0xAE, 0xCA, 0x33, 0x1A, 0xB6,
0x7E, 0x1E, 0x79, 0xB2, 0x85, 0xDD, 0x57, 0x71, 0xB5, 0xD9, 0xFF, 0x79, 0xEA, 0x63, 0x0B, 0x75
};

static const BYTE PubKeyExpV1[3] = {3};

static const BYTE PubKeyIndexV1 = 0x01;

static const BYTE PubKeyIndex0 = 0x0;

static const BYTE PubKeyExp0[3] = {3};

static const BYTE PubKeyMod0[128] = {
0x9E, 0x15, 0x21, 0x42, 0x12, 0xF6, 0x30, 0x8A,0xCA, 0x78, 0xB8, 0x0B, 0xD9, 0x86, 0xAC, 0x28,
0x75, 0x16, 0x84, 0x6C, 0x8D, 0x54, 0x8A, 0x9E,0xD0, 0xA4, 0x2E, 0x7D, 0x99, 0x7C, 0x90, 0x2C,
0x3E, 0x12, 0x2D, 0x1B, 0x9D, 0xC3, 0x09, 0x95,0xF4, 0xE2, 0x5C, 0x75, 0xDD, 0x7E, 0xE0, 0xA0,
0xCE, 0x29, 0x3B, 0x8C, 0xC0, 0x2B, 0x97, 0x72,0x78, 0xEF, 0x25, 0x6D, 0x76, 0x11, 0x94, 0x92,
0x47, 0x64, 0x94, 0x2F, 0xE7, 0x14, 0xFA, 0x02,0xE4, 0xD5, 0x7F, 0x28, 0x2B, 0xA3, 0xB2, 0xB6,
0x2C, 0x9E, 0x38, 0xEF, 0x65, 0x17, 0x82, 0x3F,0x2C, 0xA8, 0x31, 0xBD, 0xDF, 0x6D, 0x36, 0x3D
};

#endif

static const BYTE PubKeyIndexFF = 0xFF;
static const BYTE PubKeyExpFF[3] = {3};

static const BYTE PubKeyModFF[128] = {
0xB8, 0x55, 0xCC, 0x64, 0x31, 0x3A, 0xF9, 0x9C, 0x45, 0x3D, 0x18, 0x16, 0x42, 0xEE, 0x7D, 0xD2,
0x1A, 0x67, 0xD0, 0xFF, 0x50, 0xC6, 0x1F, 0xE2, 0x13, 0xBC, 0xDC, 0x18, 0xAF, 0xBC, 0xD0, 0x77,
0x22, 0xEF, 0xDD, 0x25, 0x94, 0xEF, 0xDC, 0x22, 0x7D, 0xA3, 0xDA, 0x23, 0xAD, 0xCC, 0x90, 0xE3,
0xFA, 0x90, 0x74, 0x53, 0xAC, 0xC9, 0x54, 0xC4, 0x73, 0x23, 0xBE, 0xDC, 0xF8, 0xD4, 0x86, 0x2C,
0x45, 0x7D, 0x25, 0xF4, 0x7B, 0x16, 0xD7, 0xC3, 0x50, 0x2B, 0xE0, 0x81, 0x91, 0x3E, 0x5B, 0x04,
0x82, 0xD8, 0x38, 0x48, 0x40, 0x65, 0xDA, 0x5F, 0x66, 0x59, 0xE0, 0x0A, 0x9E, 0x5D, 0x57, 0x0A,
0xDA, 0x1E, 0xC6, 0xAF, 0x8C, 0x57, 0x96, 0x00, 0x75, 0x11, 0x95, 0x81, 0xFC, 0x81, 0x46, 0x8D,
};

static const BYTE PubKeyIndexFE = 0xFE;
static const BYTE PubKeyExpFE[3] = {3};

static const BYTE PubKeyModFE[256] = {
0xA6, 0x53, 0xEA, 0xC1, 0xC0, 0xF7, 0x86, 0xC8, 0x72, 0x4F, 0x73, 0x7F, 0x17, 0x29, 0x97, 0xD6,
0x3D, 0x1C, 0x32, 0x51, 0xC4, 0x44, 0x02, 0x04, 0x9B, 0x86, 0x5B, 0xAE, 0x87, 0x7D, 0x0F, 0x39,
0x8C, 0xBF, 0xBE, 0x8A, 0x60, 0x35, 0xE2, 0x4A, 0xFA, 0x08, 0x6B, 0xEF, 0xDE, 0x93, 0x51, 0xE5,
0x4B, 0x95, 0x70, 0x8E, 0xE6, 0x72, 0xF0, 0x96, 0x8B, 0xCD, 0x50, 0xDC, 0xE4, 0x0F, 0x78, 0x33,
0x22, 0xB2, 0xAB, 0xA0, 0x4E, 0xF1, 0x37, 0xEF, 0x18, 0xAB, 0xF0, 0x3C, 0x7D, 0xBC, 0x58, 0x13,
0xAE, 0xAE, 0xF3, 0xAA, 0x77, 0x97, 0xBA, 0x15, 0xDF, 0x7D, 0x5B, 0xA1, 0xCB, 0xAF, 0x7F, 0xD5,
0x20, 0xB5, 0xA4, 0x82, 0xD8, 0xD3, 0xFE, 0xE1, 0x05, 0x07, 0x78, 0x71, 0x11, 0x3E, 0x23, 0xA4,
0x9A, 0xF3, 0x92, 0x65, 0x54, 0xA7, 0x0F, 0xE1, 0x0E, 0xD7, 0x28, 0xCF, 0x79, 0x3B, 0x62, 0xA1,
};

static const BYTE PubKeyIndexFD = 0xFD;
static const BYTE PubKeyExpFD[3] = {2};

static const BYTE PubKeyModFD[128] = {
0xB3, 0x57, 0x2B, 0xA4, 0x9A, 0xE4, 0xC7, 0xB7, 0xA0, 0x01, 0x9E, 0x51, 0x89, 0xE1, 0x42, 0xCF,
0xCD, 0xED, 0x94, 0x98, 0xDD, 0xB5, 0xF0, 0x47, 0x05, 0x67, 0xAB, 0x0B, 0xA7, 0x13, 0xB8, 0xDA,
0x22, 0x64, 0x24, 0x62, 0x29, 0x55, 0xB5, 0x4B, 0x93, 0x7A, 0xBF, 0xEF, 0xAA, 0xD9, 0x79, 0x19,
0xE3, 0x77, 0x62, 0x1E, 0x22, 0x19, 0x6A, 0xBC, 0x14, 0x19, 0xD5, 0xAD, 0xC1, 0x23, 0x48, 0x42,
0x09, 0xEA, 0x7C, 0xB7, 0x02, 0x9E, 0x66, 0xA0, 0xD5, 0x4C, 0x5B, 0x45, 0xC8, 0xAD, 0x61, 0x5A,
0xED, 0xB6, 0xAE, 0x9E, 0x0A, 0x2F, 0x75, 0x31, 0x0E, 0xA8, 0x96, 0x12, 0x87, 0x24, 0x12, 0x45,
};


static const BYTE PubKeyIndexFC = 0xFC;
static const BYTE PubKeyExpFC[3] = {2};

static const BYTE PubKeyModFC[128] = {
0xB3, 0x7B, 0xFD, 0x2A, 0x96, 0x74, 0xAD, 0x62, 0x21, 0xC1, 0xA0, 0x01, 0x08, 0x1C, 0x62, 0x65,
0x3D, 0xC2, 0x80, 0xB0, 0xA9, 0xBD, 0x05, 0x2C, 0x67, 0x7C, 0x91, 0x3C, 0xE7, 0xA0, 0xD9, 0x02,
0xE7, 0x7B, 0x12, 0xF4, 0xD4, 0xD7, 0x90, 0x37, 0xB1, 0xE9, 0xB9, 0x23, 0xA8, 0xBB, 0x3F, 0xAC,
0x3C, 0x61, 0x20, 0x45, 0xBB, 0x39, 0x14, 0xF8, 0xDF, 0x41, 0xE9, 0xA1, 0xB6, 0x1B, 0xFA, 0x5B,
0x41, 0x70, 0x5A, 0x69, 0x1D, 0x09, 0xCE, 0x6F, 0x53, 0x0F, 0xE4, 0x8B, 0x30, 0x24, 0x0D, 0x98,
0xF4, 0xE6, 0x92, 0xFF, 0xD6, 0xAA, 0xDB, 0x87, 0x24, 0x3B, 0xA8, 0x59, 0x7A, 0xB2, 0x37, 0x58,
0x6E, 0xCF, 0x25, 0x8F, 0x41, 0x48, 0x75, 0x1B, 0xE5, 0xDA, 0x5A, 0x3B, 0xE6, 0xCC, 0x34, 0xBD,
};


static const BYTE PubKeyIndexFB = 0xFB;
static const BYTE PubKeyExpFB[3] = {2};

static const BYTE PubKeyModFB[256] = {
0xA9, 0x54, 0x8D, 0xFB, 0x39, 0x8B, 0x48, 0x12, 0x3F, 0xAF, 0x41, 0xE6, 0xCF, 0xA4, 0xAE, 0x1E,
0x23, 0x52, 0xB5, 0x18, 0xAB, 0x4B, 0xCE, 0xFE, 0xCD, 0xB0, 0xB3, 0xED, 0xEC, 0x09, 0x02, 0x87,
0xD8, 0x8B, 0x12, 0x25, 0x9F, 0x36, 0x1C, 0x1C, 0xC0, 0x88, 0xE5, 0xF0, 0x66, 0x49, 0x44, 0x17,
0xE8, 0xEE, 0x8B, 0xBF, 0x89, 0x91, 0xE2, 0xB3, 0x2F, 0xF1, 0x6F, 0x99, 0x46, 0x97, 0x84, 0x2B,
0x3D, 0x6C, 0xB3, 0x7A, 0x2B, 0xB5, 0x74, 0x2A, 0x44, 0x0B, 0x63, 0x56, 0xC6, 0x2A, 0xA3, 0x3D,
0xB3, 0xC4, 0x55, 0xE5, 0x9E, 0xDD, 0xF7, 0x86, 0x47, 0x01, 0xD0, 0x3A, 0x5B, 0x83, 0xEE, 0x9E,
0x9B, 0xD8, 0x3A, 0xB9, 0x33, 0x02, 0xAC, 0x2D, 0xFE, 0x63, 0xE6, 0x61, 0x20, 0xB0, 0x51, 0xCF,
0x08, 0x1F, 0x56, 0x32, 0x6A, 0x71, 0x30, 0x3D, 0x95, 0x2B, 0xB3, 0x36, 0xFF, 0x12, 0x61, 0x0D,
};


static const BYTE PubKeyIndexFA = 0xFA;
static const BYTE PubKeyExpFA[3] = {3};

static const BYTE PubKeyModFA[256] = {
0x9C, 0x6B, 0xE5, 0xAD, 0xB1, 0x0B, 0x4B, 0xE3, 0xDC, 0xE2, 0x09, 0x9B, 0x4B, 0x21, 0x06, 0x72,
0xB8, 0x96, 0x56, 0xEB, 0xA0, 0x91, 0x20, 0x4F, 0x61, 0x3E, 0xCC, 0x62, 0x3B, 0xED, 0xC9, 0xC6,
0xD7, 0x7B, 0x66, 0x0E, 0x8B, 0xAE, 0xEA, 0x7F, 0x7C, 0xE3, 0x0F, 0x1B, 0x15, 0x38, 0x79, 0xA4,
0xE3, 0x64, 0x59, 0x34, 0x3D, 0x1F, 0xE4, 0x7A, 0xCD, 0xBD, 0x41, 0xFC, 0xD7, 0x10, 0x03, 0x0C,
0x2B, 0xA1, 0xD9, 0x46, 0x15, 0x97, 0x98, 0x2C, 0x6E, 0x1B, 0xDD, 0x08, 0x55, 0x4B, 0x72, 0x6F,
0x5E, 0xFF, 0x79, 0x13, 0xCE, 0x59, 0xE7, 0x9E, 0x35, 0x72, 0x95, 0xC3, 0x21, 0xE2, 0x6D, 0x0B,
0x8B, 0xE2, 0x70, 0xA9, 0x44, 0x23, 0x45, 0xC7, 0x53, 0xE2, 0xAA, 0x2A, 0xCF, 0xC9, 0xD3, 0x08,
0x50, 0x60, 0x2F, 0xE6, 0xCA, 0xC0, 0x0C, 0x6D, 0xDF, 0x6B, 0x8D, 0x9D, 0x9B, 0x48, 0x79, 0xB2,
0x82, 0x6B, 0x04, 0x2A, 0x07, 0xF0, 0xE5, 0xAE, 0x52, 0x6A, 0x3D, 0x3C, 0x4D, 0x22, 0xC7, 0x2B,
0x9E, 0xAA, 0x52, 0xEE, 0xD8, 0x89, 0x38, 0x66, 0xF8, 0x66, 0x38, 0x7A, 0xC0, 0x5A, 0x13, 0x99,
};

static const BYTE PubKeyIndexF9 = 0xF9;
static const BYTE PubKeyExpF9[3] = {3};

static const BYTE PubKeyModF9[256] = {
0xA9, 0x9A, 0x6D, 0x3E, 0x07, 0x18, 0x89, 0xED, 0x9E, 0x3A, 0x0C, 0x39, 0x1C, 0x69, 0xB0, 0xB8,
0x04, 0xFC, 0x16, 0x0B, 0x2B, 0x4B, 0xDD, 0x57, 0x0C, 0x92, 0xDD, 0x5A, 0x0F, 0x45, 0xF5, 0x3E,
0x86, 0x21, 0xF7, 0xC9, 0x6C, 0x40, 0x22, 0x42, 0x66, 0x73, 0x5E, 0x1E, 0xE1, 0xB3, 0xC0, 0x62,
0x38, 0xAE, 0x35, 0x04, 0x63, 0x20, 0xFD, 0x8E, 0x81, 0xF8, 0xCE, 0xB3, 0xF8, 0xB4, 0xC9, 0x7B,
0x94, 0x09, 0x30, 0xA3, 0xAC, 0x5E, 0x79, 0x00, 0x86, 0xDA, 0xD4, 0x1A, 0x6A, 0x4F, 0x51, 0x17,
0xBA, 0x1C, 0xE2, 0x43, 0x8A, 0x51, 0xAC, 0x05, 0x3E, 0xB0, 0x02, 0xAE, 0xD8, 0x66, 0xD2, 0xC4,
0x58, 0xFD, 0x73, 0x35, 0x90, 0x21, 0xA1, 0x20, 0x29, 0xA0, 0xC0, 0x43, 0x04, 0x5C, 0x11, 0x66,
0x4F, 0xE0, 0x21, 0x9E, 0xC6, 0x3C, 0x10, 0xBF, 0x21, 0x55, 0xBB, 0x27, 0x84, 0x60, 0x9A, 0x10,
0x64, 0x21, 0xD4, 0x51, 0x63, 0x79, 0x97, 0x38, 0xC1, 0xC3, 0x09, 0x09, 0xBB, 0x6C, 0x6F, 0xE5,
0x2B, 0xBB, 0x76, 0x39, 0x7B, 0x97, 0x40, 0xCE, 0x06, 0x4A, 0x61, 0x3F, 0xF8, 0x41, 0x11, 0x85,
0xF0, 0x88, 0x42, 0xA4, 0x23, 0xEA, 0xD2, 0x0E, 0xDF, 0xFB, 0xFF, 0x1C, 0xD6, 0xC3, 0xFE, 0x0C,
0x98, 0x21, 0x47, 0x91, 0x99, 0xC2, 0x6D, 0x85, 0x72, 0xCC, 0x8A, 0xFF, 0xF0, 0x87, 0xA9, 0xC3,
};

static const BYTE PubKeyIndexF8 = 0xF8;
static const BYTE PubKeyExpF8[3] = {3};

static const BYTE PubKeyModF8[128] = {
0xA1,0xF5,0xE1,0xC9,0xBD,0x86,0x50,0xBD,0x43,0xAB,0x6E,0xE5,0x6B,0x89,0x1E,0xF7,0x45,0x9C,0x0A,
0x24,0xFA,0x84,0xF9,0x12,0x7D,0x1A,0x6C,0x79,0xD4,0x93,0x0F,0x6D,0xB1,0x85,0x2E,0x25,0x10,0xF1,
0x8B,0x61,0xCD,0x35,0x4D,0xB8,0x3A,0x35,0x6B,0xD1,0x90,0xB8,0x8A,0xB8,0xDF,0x04,0x28,0x4D,0x02,
0xA4,0x20,0x4A,0x7B,0x6C,0xB7,0xC5,0x55,0x19,0x77,0xA9,0xB3,0x63,0x79,0xCA,0x3D,0xE1,0xA0,0x8E,
0x69,0xF3,0x01,0xC9,0x5C,0xC1,0xC2,0x05,0x06,0x95,0x92,0x75,0xF4,0x17,0x23,0xDD,0x5D,0x29,0x25,
0x29,0x05,0x79,0xE5,0xA9,0x5B,0x0D,0xF6,0x32,0x3F,0xC8,0xE9,0x27,0x3D,0x6F,0x84,0x91,0x98,0xC4,
0x99,0x62,0x09,0x16,0x6D,0x9B,0xFC,0x97,0x3C,0x36,0x1C,0xC8,0x26,0xE1
};


static const BYTE PubKeyIndexF7 = 0xF7;
static const BYTE PubKeyExpF7[3] = {1,0,1};

static const BYTE PubKeyModF7[256] = {
0x94, 0xEA, 0x62, 0xF6, 0xD5, 0x83, 0x20, 0xE3, 0x54, 0xC0, 0x22, 0xAD, 0xDC, 0xF0, 0x55, 0x9D,
0x8C, 0xF2, 0x06, 0xCD, 0x92, 0xE8, 0x69, 0x56, 0x49, 0x05, 0xCE, 0x21, 0xD7, 0x20, 0xF9, 0x71,
0xB7, 0xAE, 0xA3, 0x74, 0x83, 0x0E, 0xBE, 0x17, 0x57, 0x11, 0x5A, 0x85, 0xE0, 0x88, 0xD4, 0x1C,
0x6B, 0x77, 0xCF, 0x5E, 0xC8, 0x21, 0xF3, 0x0B, 0x1D, 0x89, 0x04, 0x17, 0xBF, 0x2F, 0xA3, 0x1E,
0x59, 0x08, 0xDE, 0xD5, 0xFA, 0x67, 0x7F, 0x8C, 0x7B, 0x18, 0x4A, 0xD0, 0x90, 0x28, 0xFD, 0xDE,
0x96, 0xB6, 0xA6, 0x10, 0x98, 0x50, 0xAA, 0x80, 0x01, 0x75, 0xEA, 0xBC, 0xDB, 0xBB, 0x68, 0x4A,
0x96, 0xC2, 0xEB, 0x63, 0x79, 0xDF, 0xEA, 0x08, 0xD3, 0x2F, 0xE2, 0x33, 0x1F, 0xE1, 0x03, 0x23,
0x3A, 0xD5, 0x8D, 0xCD, 0xB1, 0xE6, 0xE0, 0x77, 0xCB, 0x9F, 0x24, 0xEA, 0xEC, 0x5C, 0x25, 0xAF,
};

static const BYTE PubKeyIndexF6 = 0xF6;
static const BYTE PubKeyExpF6[3] = {3};

static const BYTE PubKeyModF6[256] = {
0xA2, 0x5A, 0x6B, 0xD7, 0x83, 0xA5, 0xEF, 0x6B, 0x8F, 0xB6, 0xF8, 0x30, 0x55, 0xC2, 0x60, 0xF5,
0xF9, 0x9E, 0xA1, 0x66, 0x78, 0xF3, 0xB9, 0x05, 0x3E, 0x0F, 0x64, 0x98, 0xE8, 0x2C, 0x3F, 0x5D,
0x1E, 0x8C, 0x38, 0xF1, 0x35, 0x88, 0x01, 0x7E, 0x2B, 0x12, 0xB3, 0xD8, 0xFF, 0x6F, 0x50, 0x16,
0x7F, 0x46, 0x44, 0x29, 0x10, 0x72, 0x9E, 0x9E, 0x4D, 0x1B, 0x37, 0x39, 0xE5, 0x06, 0x7C, 0x0A,
0xC7, 0xA1, 0xF4, 0x48, 0x7E, 0x35, 0xF6, 0x75, 0xBC, 0x16, 0xE2, 0x33, 0x31, 0x51, 0x65, 0xCB,
0x14, 0x2B, 0xFD, 0xB2, 0x5E, 0x30, 0x1A, 0x63, 0x2A, 0x54, 0xA3, 0x37, 0x1E, 0xBA, 0xB6, 0x57,
0x2D, 0xEE, 0xBA, 0xF3, 0x70, 0xF3, 0x37, 0xF0, 0x57, 0xEE, 0x73, 0xB4, 0xAE, 0x46, 0xD1, 0xA8,
0xBC, 0x4D, 0xA8, 0x53, 0xEC, 0x3C, 0xC1, 0x2C, 0x8C, 0xBC, 0x2D, 0xA1, 0x83, 0x22, 0xD6, 0x85,
0x30, 0xC7, 0x0B, 0x22, 0xBD, 0xAC, 0x35, 0x1D, 0xD3, 0x60, 0x68, 0xAE, 0x32, 0x1E, 0x11, 0xAB,
0xF2, 0x64, 0xF4, 0xD3, 0x56, 0x9B, 0xB7, 0x12, 0x14, 0x54, 0x50, 0x05, 0x55, 0x8D, 0xE2, 0x60,
0x83, 0xC7, 0x35, 0xDB, 0x77, 0x63, 0x68, 0x17, 0x2F, 0xE8, 0xC2, 0xF5, 0xC8, 0x5E, 0x8B, 0x5B,
0x89, 0x0C, 0xC6, 0x82, 0x91, 0x1D, 0x2D, 0xE7, 0x1F, 0xA6, 0x26, 0xB8, 0x81, 0x7F, 0xCC, 0xC0,
0x89, 0x22, 0xB7, 0x03, 0x86, 0x9F, 0x3B, 0xAE, 0xAC, 0x14, 0x59, 0xD7, 0x7C, 0xD8, 0x53, 0x76,
0xBC, 0x36, 0x18, 0x2F, 0x42, 0x38, 0x31, 0x4D, 0x6C, 0x42, 0x12, 0xFB, 0xDD, 0x7F, 0x23, 0xD3,
};

static const BYTE PubKeyIndexF5 = 0xF5;
static const BYTE PubKeyExpF5[3] = {1,0,1};

static const BYTE PubKeyModF5[256] = {
0xA6, 0xE6, 0xFB, 0x72, 0x17, 0x95, 0x06, 0xF8, 0x60, 0xCC, 0xCA, 0x8C, 0x27, 0xF9, 0x9C, 0xEC,
0xD9, 0x4C, 0x7D, 0x4F, 0x31, 0x91, 0xD3, 0x03, 0xBB, 0xEE, 0x37, 0x48, 0x1C, 0x7A, 0xA1, 0x5F,
0x23, 0x3B, 0xA7, 0x55, 0xE9, 0xE4, 0x37, 0x63, 0x45, 0xA9, 0xA6, 0x7E, 0x79, 0x94, 0xBD, 0xC1,
0xC6, 0x80, 0xBB, 0x35, 0x22, 0xD8, 0xC9, 0x3E, 0xB0, 0xCC, 0xC9, 0x1A, 0xD3, 0x1A, 0xD4, 0x50,
0xDA, 0x30, 0xD3, 0x37, 0x66, 0x2D, 0x19, 0xAC, 0x03, 0xE2, 0xB4, 0xEF, 0x5F, 0x6E, 0xC1, 0x82,
0x82, 0xD4, 0x91, 0xE1, 0x97, 0x67, 0xD7, 0xB2, 0x45, 0x42, 0xDF, 0xDE, 0xFF, 0x6F, 0x62, 0x18,
0x55, 0x03, 0x53, 0x20, 0x69, 0xBB, 0xB3, 0x69, 0xE3, 0xBB, 0x9F, 0xB1, 0x9A, 0xC6, 0xF1, 0xC3,
0x0B, 0x97, 0xD2, 0x49, 0xEE, 0xE7, 0x64, 0xE0, 0xBA, 0xC9, 0x7F, 0x25, 0xC8, 0x73, 0xD9, 0x73,
0x95, 0x3E, 0x51, 0x53, 0xA4, 0x20, 0x64, 0xBB, 0xFA, 0xBF, 0xD0, 0x6A, 0x4B, 0xB4, 0x86, 0x86,
0x0B, 0xF6, 0x63, 0x74, 0x06, 0xC9, 0xFC, 0x36, 0x81, 0x3A, 0x4A, 0x75, 0xF7, 0x5C, 0x31, 0xCC,
0xA9, 0xF6, 0x9F, 0x8D, 0xE5, 0x9A, 0xDE, 0xCE, 0xF6, 0xBD, 0xE7, 0xE0, 0x78, 0x00, 0xFC, 0xBE,
0x03, 0x5D, 0x31, 0x76, 0xAF, 0x84, 0x73, 0xE2, 0x3E, 0x9A, 0xA3, 0xDF, 0xEE, 0x22, 0x11, 0x96,
0xD1, 0x14, 0x83, 0x02, 0x67, 0x7C, 0x72, 0x0C, 0xFE, 0x25, 0x44, 0xA0, 0x3D, 0xB5, 0x53, 0xE7,
0xF1, 0xB8, 0x42, 0x7B, 0xA1, 0xCC, 0x72, 0xB0, 0xF2, 0x9B, 0x12, 0xDF, 0xEF, 0x4C, 0x08, 0x1D,
0x07, 0x6D, 0x35, 0x3E, 0x71, 0x88, 0x0A, 0xAD, 0xFF, 0x38, 0x63, 0x52, 0xAF, 0x0A, 0xB7, 0xB2,
0x8E, 0xD4, 0x9E, 0x1E, 0x67, 0x2D, 0x11, 0xF9,
};


static const BYTE PubKeyIndexF9_2 = 0xF9;
static const BYTE PubKeyExpF9_2[3] = {1,0,1};

static const BYTE PubKeyModF9_2[256] = {
0xA6, 0xE6, 0xFB, 0x72, 0x17, 0x95, 0x06, 0xF8, 0x60, 0xCC, 0xCA, 0x8C, 0x27, 0xF9, 0x9C, 0xEC,
0xD9, 0x4C, 0x7D, 0x4F, 0x31, 0x91, 0xD3, 0x03, 0xBB, 0xEE, 0x37, 0x48, 0x1C, 0x7A, 0xA1, 0x5F,
0x23, 0x3B, 0xA7, 0x55, 0xE9, 0xE4, 0x37, 0x63, 0x45, 0xA9, 0xA6, 0x7E, 0x79, 0x94, 0xBD, 0xC1,
0xC6, 0x80, 0xBB, 0x35, 0x22, 0xD8, 0xC9, 0x3E, 0xB0, 0xCC, 0xC9, 0x1A, 0xD3, 0x1A, 0xD4, 0x50,
0xDA, 0x30, 0xD3, 0x37, 0x66, 0x2D, 0x19, 0xAC, 0x03, 0xE2, 0xB4, 0xEF, 0x5F, 0x6E, 0xC1, 0x82,
0x82, 0xD4, 0x91, 0xE1, 0x97, 0x67, 0xD7, 0xB2, 0x45, 0x42, 0xDF, 0xDE, 0xFF, 0x6F, 0x62, 0x18,
0x55, 0x03, 0x53, 0x20, 0x69, 0xBB, 0xB3, 0x69, 0xE3, 0xBB, 0x9F, 0xB1, 0x9A, 0xC6, 0xF1, 0xC3,
0x0B, 0x97, 0xD2, 0x49, 0xEE, 0xE7, 0x64, 0xE0, 0xBA, 0xC9, 0x7F, 0x25, 0xC8, 0x73, 0xD9, 0x73,
0x95, 0x3E, 0x51, 0x53, 0xA4, 0x20, 0x64, 0xBB, 0xFA, 0xBF, 0xD0, 0x6A, 0x4B, 0xB4, 0x86, 0x86,
0x0B, 0xF6, 0x63, 0x74, 0x06, 0xC9, 0xFC, 0x36, 0x81, 0x3A, 0x4A, 0x75, 0xF7, 0x5C, 0x31, 0xCC,
0xA9, 0xF6, 0x9F, 0x8D, 0xE5, 0x9A, 0xDE, 0xCE, 0xF6, 0xBD, 0xE7, 0xE0, 0x78, 0x00, 0xFC, 0xBE,
0x03, 0x5D, 0x31, 0x76, 0xAF, 0x84, 0x73, 0xE2, 0x3E, 0x9A, 0xA3, 0xDF, 0xEE, 0x22, 0x11, 0x96,
0xD1, 0x14, 0x83, 0x02, 0x67, 0x7C, 0x72, 0x0C, 0xFE, 0x25, 0x44, 0xA0, 0x3D, 0xB5, 0x53, 0xE7,
0xF1, 0xB8, 0x42, 0x7B, 0xA1, 0xCC, 0x72, 0xB0, 0xF2, 0x9B, 0x12, 0xDF, 0xEF, 0x4C, 0x08, 0x1D,
0x07, 0x6D, 0x35, 0x3E, 0x71, 0x88, 0x0A, 0xAD, 0xFF, 0x38, 0x63, 0x52, 0xAF, 0x0A, 0xB7, 0xB2,
0x8E, 0xD4, 0x9E, 0x1E, 0x67, 0x2D, 0x11, 0xF9
};

static const BYTE PubKeyIndexF3 = 0xF3;
static const BYTE PubKeyExpF3[3] = {3};

static const BYTE PubKeyModF3[256] = {
  0x98, 0xF0, 0xC7, 0x70, 0xF2, 0x38, 0x64, 0xC2, 
  0xE7, 0x66, 0xDF, 0x02, 0xD1, 0xE8, 0x33, 0xDF,
  0xF4, 0xFF, 0xE9, 0x2D, 0x69, 0x6E, 0x16, 0x42, 
  0xF0, 0xA8, 0x8C, 0x56, 0x94, 0xC6, 0x47, 0x9D,
  0x16, 0xDB, 0x15, 0x37, 0xBF, 0xE2, 0x9E, 0x4F, 
  0xDC, 0x6E, 0x6E, 0x8A, 0xFD, 0x1B, 0x0E, 0xB7,
  0xEA, 0x01, 0x24, 0x72, 0x3C, 0x33, 0x31, 0x79, 
  0xBF, 0x19, 0xE9, 0x3F, 0x10, 0x65, 0x8B, 0x2F,
  0x77, 0x6E, 0x82, 0x9E, 0x87, 0xDA, 0xED, 0xA9, 
  0xC9, 0x4A, 0x8B, 0x33, 0x82, 0x19, 0x9A, 0x35,
  0x0C, 0x07, 0x79, 0x77, 0xC9, 0x7A, 0xFF, 0x08, 
  0xFD, 0x11, 0x31, 0x0A, 0xC9, 0x50, 0xA7, 0x2C,
  0x3C, 0xA5, 0x00, 0x2E, 0xF5, 0x13, 0xFC, 0xCC, 
  0x28, 0x6E, 0x64, 0x6E, 0x3C, 0x53, 0x87, 0x53,
  0x5D, 0x50, 0x95, 0x14, 0xB3, 0xB3, 0x26, 0xE1, 
  0x23, 0x4F, 0x9C, 0xB4, 0x8C, 0x36, 0xDD, 0xD4,
  0x4B, 0x41, 0x6D, 0x23, 0x65, 0x40, 0x34, 0xA6, 
  0x6F, 0x40, 0x3B, 0xA5, 0x11, 0xC5, 0xEF, 0xA3
};

//BONUS
static const BYTE PubKeyIndex02 = 0x02;
static const BYTE PubKeyExp02[3] = {3};

static const BYTE PubKeyMod02[256] = {
  0xCF, 0x42, 0x64, 0xE1, 0x70, 0x2D, 0x34, 0xCA, 
  0x89, 0x7D, 0x1F, 0x9B, 0x66, 0xC5, 0xD6, 0x36,		 
  0x91, 0xEA, 0xCC, 0x61, 0x2C, 0x8F, 0x14, 0x71,
  0x16, 0xBB, 0x22, 0xD0, 0xC4, 0x63, 0x49, 0x5B,
  0xD5, 0xBA, 0x70, 0xFB, 0x15, 0x38, 0x48, 0x89, 
  0x52, 0x20, 0xB8, 0xAD, 0xEE, 0xC3, 0xE7, 0xBA,
  0xB3, 0x1E, 0xA2, 0x2C, 0x1D, 0xC9, 0x97, 0x2F, 
  0xA0, 0x27, 0xD5, 0x42, 0x65, 0xBE, 0xBF, 0x0A,		 
  0xE3, 0xA2, 0x3A, 0x8A, 0x09, 0x18, 0x7F, 0x21,
  0xC8, 0x56, 0x60, 0x7B, 0x98, 0xBD, 0xA6, 0xFC,		 
  0x90, 0x81, 0x16, 0x81, 0x6C, 0x50, 0x2B, 0x3E, 
  0x58, 0xA1, 0x45, 0x25, 0x4E, 0xEF, 0xEE, 0x2A,		 
  0x33, 0x35, 0x11, 0x02, 0x24, 0x02, 0x8B, 0x67, 
  0x80, 0x9D, 0xCB, 0x80, 0x58, 0xE2, 0x48, 0x95
};

static const BYTE PubKeyIndex03 = 0x03;
static const BYTE PubKeyExp03[3] = {3};

static const BYTE PubKeyMod03[256] = {
  0xC2, 0x49, 0x07, 0x47, 0xFE, 0x17, 0xEB, 0x05,
  0x84, 0xC8, 0x8D, 0x47, 0xB1, 0x60, 0x27, 0x04,		 
  0x15, 0x0A, 0xDC, 0x88, 0xC5, 0xB9, 0x98, 0xBD,
  0x59, 0xCE, 0x04, 0x3E, 0xDE, 0xBF, 0x0F, 0xFE,		 
  0xE3, 0x09, 0x3A, 0xC7, 0x95, 0x6A, 0xD3, 0xB6,
  0xAD, 0x45, 0x54, 0xC6, 0xDE, 0x19, 0xA1, 0x78,		 
  0xD6, 0xDA, 0x29, 0x5B, 0xE1, 0x5D, 0x52, 0x20,
  0x64, 0x5E, 0x3C, 0x81, 0x31, 0x66, 0x6F, 0xA4,		 
  0xBE, 0x5B, 0x84, 0xFE, 0x13, 0x1E, 0xA4, 0x4B,
  0x03, 0x93, 0x07, 0x63, 0x8B, 0x9E, 0x74, 0xA8,		 
  0xC4, 0x25, 0x64, 0xF8, 0x92, 0xA6, 0x4D, 0xF1,
  0xCB, 0x15, 0x71, 0x2B, 0x73, 0x6E, 0x33, 0x74,		 
  0xF1, 0xBB, 0xB6, 0x81, 0x93, 0x71, 0x60, 0x2D,
  0x89, 0x70, 0xE9, 0x7B, 0x90, 0x07, 0x93, 0xC7,		 
  0xC2, 0xA8, 0x9A, 0x4A, 0x16, 0x49, 0xA5, 0x9B,
  0xE6, 0x80, 0x57, 0x4D, 0xD0, 0xB6, 0x01, 0x45
};

static const BYTE PubKeyIndex04 = 0x04;
static const BYTE PubKeyExp04[3] = {3};

static const BYTE PubKeyMod04[256] = {
  0xA6, 0xDA, 0x42, 0x83, 0x87, 0xA5, 0x02, 0xD7,
  0xDD, 0xFB, 0x7A, 0x74, 0xD3, 0xF4, 0x12, 0xBE,
  0x76, 0x26, 0x27, 0x19, 0x7B, 0x25, 0x43, 0x5B,
  0x7A, 0x81, 0x71, 0x6A, 0x70, 0x01, 0x57, 0xDD,		 
  0xD0, 0x6F, 0x7C, 0xC9, 0x9D, 0x6C, 0xA2, 0x8C,
  0x24, 0x70, 0x52, 0x7E, 0x2C, 0x03, 0x61, 0x6B,
  0x9C, 0x59, 0x21, 0x73, 0x57, 0xC2, 0x67, 0x4F,
  0x58, 0x3B, 0x3B, 0xA5, 0xC7, 0xDC, 0xF2, 0x83,
  0x86, 0x92, 0xD0, 0x23, 0xE3, 0x56, 0x24, 0x20,
  0xB4, 0x61, 0x5C, 0x43, 0x9C, 0xA9, 0x7C, 0x44,
  0xDC, 0x9A, 0x24, 0x9C, 0xFC, 0xE7, 0xB3, 0xBF,
  0xB2, 0x2F, 0x68, 0x22, 0x8C, 0x3A, 0xF1, 0x33,
  0x29, 0xAA, 0x4A, 0x61, 0x3C, 0xF8, 0xDD, 0x85,
  0x35, 0x02, 0x37, 0x3D, 0x62, 0xE4, 0x9A, 0xB2,
  0x56, 0xD2, 0xBC, 0x17, 0x12, 0x0E, 0x54, 0xAE,
  0xDC, 0xED, 0x6D, 0x96, 0xA4, 0x28, 0x7A, 0xCC,
  0x5C, 0x04, 0x67, 0x7D, 0x4A, 0x5A, 0x32, 0x0D,
  0xB8, 0xBE, 0xE2, 0xF7, 0x75, 0xE5, 0xFE, 0xC5
};



// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	ON_WM_CREATE()
	ON_WM_ACTIVATE()
	ON_WM_SHOWWINDOW()
	ON_MESSAGE( UM_SCARD_READER, OnReaderMessage )
	ON_COMMAND(ID_SETTING_VIRTUALPOSSETTING, OnVirtualPosSetting)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};


// CMainFrame construction/destruction

CMainFrame::CMainFrame()
					:m_BatchNo(1)
					,m_SeqNo(1)
					,m_strTerminalID(_T("00009000"))
					,m_strMerchantID(_T("000000002565"))
					,m_strMerchantName(_T("VERISOFT DEMO"))
{
	// TODO: add member initialization code here

	memcpy( m_MasterKey, "0123456789012345", 16);
	memset( m_InsKey, '0', 16);
}

CMainFrame::~CMainFrame()
{
}


void CMainFrame::OnShowWindow(BOOL bShow,UINT nStatus)
{
	CFrameWnd::OnShowWindow(bShow,nStatus);

}


void CMainFrame::OnActivate(UINT nState,CWnd* pWndOther,BOOL bMinimized)
{
	CFrameWnd::OnActivate( nState, pWndOther, bMinimized);

	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);

	pFrame->cntReaderName.SetWindowText( "Reader: " + m_ReaderName );

	pFrame->cntTerminalID.SetWindowText( m_strTerminalID );
	pFrame->cntMerchantID.SetWindowText( m_strMerchantID );
	pFrame->cntMerchantName.SetWindowText( m_strMerchantName );
	CString BatchNo, SeqNo;
	BatchNo.Format("%d", m_BatchNo);
	SeqNo.Format("%d", m_SeqNo);
	pFrame->cntCurrBatchNo.SetWindowText( BatchNo );
	pFrame->cntCurrSeqNo.SetWindowText( SeqNo );

}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}
	// TODO: Delete these three lines if you don't want the toolbar to be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

//	SetDlgItemText(ID_VIEW_STATUS_BAR,"HEHEHE");
//	m_wndStatusBar.SetWindowText("HEHEHEHH");
	SetWindowText("Virtual EMV POS version 0.01 beta");
	

	m_ReaderManager = new CSmartCardReaderManager(this);
	
	m_pReader = NULL;
	m_protocol = 0;
	m_bReady = FALSE;
	InitializeCriticalSection(&m_cs);

	CStringArray readernames;

	m_ReaderManager->GetReaderNames(readernames);

	int count = (int)readernames.GetCount();
	if(count == 0){
		AfxMessageBox("There is no reader attached!");
		return FALSE;
	}

	if (m_pReader) delete m_pReader;


	//Unlock();
	

	m_ReaderName = readernames.GetAt(0);

	m_wndStatusBar.SetWindowText( "Virtual POS is Ready." );
	

		return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
								CCreateContext* pContext)
{

	if (!m_wndSplitter.CreateStatic(this, 1, 2))
		return FALSE;

	if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CInfoFrame), CSize(350, 200), pContext) 
		|| !m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CTransactionView), CSize(100, 90), pContext)
		)
	{
		m_wndSplitter.DestroyWindow();
		return FALSE;
	}
	return TRUE;
}



BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	

	cs.style = WS_OVERLAPPED | WS_CAPTION | FWS_ADDTOTITLE
			 | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX 
			 | WS_MAXIMIZE | WS_SYSMENU;	
	
	cs.style &= ~FWS_ADDTOTITLE ; // get rid of 'Untitled' in main window caption.


	return TRUE;
}


// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG


// CMainFrame message handlers




BYTE CMainFrame::GetSerialNumber(UCHAR *SerialNum)
{
   memcpy(SerialNum, "123456" ,6);    
   
   return PROCESS_OK;
}   

void CMainFrame::PrepCAKEYS( void )
{
	// Virtual Function 
    int index=0;
	

// KEY 0
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp0, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod0, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex0;

// KEY FF
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFF, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 112;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFF, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFF;


// KEY FE
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFE, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFE, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFE;


// KEY FD
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFD, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 96;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFD, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFD;


// KEY FC
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFC, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 112;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFC, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFC;


// KEY FB
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFB, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFB, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFB;


// KEY FA
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpFA, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 160;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModFA, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexFA;


// KEY F9
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF9, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 192;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF9, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexF9;

// KEY F8
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF8, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF8, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexF8;


// KEY F7
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 3;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF7, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF7, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexF7;


// KEY F6
	index++;
 	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

   	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF6, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 224;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF6, m_cakeys[index].ucPKModuloLen);
   	m_cakeys[index].ucPKIndex = PubKeyIndexF6;


// KEY F5
   	index++;
   	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

   	m_cakeys[index].ucPKExpLen = 3;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF5, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 248;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF5, m_cakeys[index].ucPKModuloLen);
   	m_cakeys[index].ucPKIndex = PubKeyIndexF5;


// KEY F9_2
   	index++;
   	m_cakeys[index].ucRid[0] = 0xB0;
	m_cakeys[index].ucRid[1] = 0x12;
	m_cakeys[index].ucRid[2] = 0x34;
	m_cakeys[index].ucRid[3] = 0x56;
	m_cakeys[index].ucRid[4] = 0x78;

   	m_cakeys[index].ucPKExpLen = 3;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF9_2, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 248;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF9_2, m_cakeys[index].ucPKModuloLen);
   	m_cakeys[index].ucPKIndex = PubKeyIndexF9_2;
        
	
// KEY F3
	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpF3, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 144;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModF3, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexF3;

// KEY 02
   index++;
   m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

   m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp02, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 112;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod02, m_cakeys[index].ucPKModuloLen);
   m_cakeys[index].ucPKIndex = PubKeyIndex02;

// KEY 03
   index++;
   m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

   m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp03, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod03, m_cakeys[index].ucPKModuloLen);
   m_cakeys[index].ucPKIndex = PubKeyIndex03;

// KEY 04
   index++;
   m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x04;

   m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp04, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 144;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod04, m_cakeys[index].ucPKModuloLen);
   m_cakeys[index].ucPKIndex = PubKeyIndex04;


// VISA KEYS

#ifdef VISA_CA_PRODUCTION_PUBLIC_KEY 	// changed by Ferhat
					// not: Production Public Keys eksik?????
// changed by Ferhat
/*	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpV5, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 96;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModV5, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexV5;*/


	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpV3, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 112;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModV3, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexV3;


	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExpV1, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyModV1, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndexV1;

#endif
#ifdef VISA_CA_TEST_PUBLIC_KEYS // changed by Ferhat


	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp95, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 144;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod95, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex95;

	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp96, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod96, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex96;


// changed by Ferhat
/*	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp97, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 96;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod97, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex97;*/


	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp98, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 112;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod98, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex98;


	index++;
	m_cakeys[index].ucRid[0] = 0xA0;
	m_cakeys[index].ucRid[1] = 0x00;
	m_cakeys[index].ucRid[2] = 0x00;
	m_cakeys[index].ucRid[3] = 0x00;
	m_cakeys[index].ucRid[4] = 0x03;
	
	m_cakeys[index].ucPKExpLen = 1;
	memcpy(m_cakeys[index].ucPKExp, PubKeyExp99, m_cakeys[index].ucPKExpLen);
	m_cakeys[index].ucPKModuloLen = 128;
	memcpy(m_cakeys[index].ucPKModulo, PubKeyMod99, m_cakeys[index].ucPKModuloLen);
	m_cakeys[index].ucPKIndex = PubKeyIndex99;

#endif

	m_NumOfCakeys=index+1;     
}



void CMainFrame::SetTermVersion( void )
{
	// Virtual Function

	m_EMVTermTags.t9F09[0]=2;
	if( GetCardBrand() == BRAND_VISA)
		m_EMVTermTags.t9F09[2]=0x84;
	else 
		m_EMVTermTags.t9F09[2]=0x02;
}

BYTE CMainFrame::CheckPinBlockBIN( void )
{
	// Virtual Function
	return NO_BIN_PERMISSION;
}

BYTE CMainFrame::ExtractFromChip( void )
{
	// Virtual Function
	BYTE i;
	BYTE ucDataValue[256];
	WORD Length;

	memset( m_CardNumber, 0, 24);
	memset( m_Expiry, ' ', 4 );
	m_Expiry[4] = 0;
	memset( m_ServiceCode, 0,4 );


	if( GetDataElement( TAG_AppPan, ucDataValue, &Length) != ACCESS_OK ) return EXTRACT_ERROR;
	Bcd2Str( ucDataValue, Length, 0, (char *)m_CardNumber );

	m_CardNumber[Length*2]='\0';


	m_strCardNumber = CString(m_CardNumber);
	WriteLogFile("PAN NUMBER", m_strCardNumber );

	for (i=0; i<Length*2; i++ ) 
	{
		if( m_CardNumber[i]=='F' ) m_CardNumber[i] = '\0';
	}

	m_T.CardLen = (BYTE)strlen( (char *)m_CardNumber );
	Pack( BASEDEC, m_CardNumber, m_T.PCardNo, m_T.CardLen );

	if( GetDataElement(TAG_Trk2EquDat, ucDataValue, &Length ) != ACCESS_OK ) return EXTRACT_ERROR;
    Bcd2Str( ucDataValue, Length, 0, (char *)m_StripeData);
   	
	m_strStripeData = CString(m_StripeData);
	WriteLogFile("TRACK 2 DATA", m_strStripeData );
   	
	for( i=0; i<39; i++ ) 
   	{
		if( m_StripeData[i]=='F') m_StripeData[i]=0;
	}
	
   	/* extract S.CardNumber and calculate CardLrc */
   	for( i=1; i<23; i++ ) 
   	{
      		if( (m_StripeData[i] == 'D') || (m_StripeData[i] == US) ) 
      		{
         		break;
      		}
   	}

   	for( i=10; i<22; i++ ) /* 19 -> 22 !!! */
      		if( (m_StripeData[i] == 'D') || (m_StripeData[i] == US) ) break;

   	/* reorganize S.StripeData for authorization */
   	if( m_StripeData[i]=='D') m_StripeData[i]='=';

   	i++;

   	if( m_StripeData[0]=='B' )
   	{
	      	WORD j;
      		m_StripeData[0] = ';';
      		for( j=i; j<40; j++ ) 
      		{
         		if( m_StripeData[j]=='F' )
         		{
            			m_StripeData[j] = '?';
            			j++;
            			m_StripeData[++j] = 0;
            			break;
         		}
      		}
   	}

   	//m_Expiry
   	if( GetDataElement(TAG_AppExpDat, ucDataValue, &Length) != ACCESS_OK ) return EXTRACT_ERROR;
   	if( Length > 2 ) 
   	{
   		Length = 2;
   	}
	Bcd2Str( ucDataValue, Length, 0, (char *)m_Expiry );
	Pack( BASEDEC, m_Expiry, m_T.Expiry, 4 );
	m_strExpiry.Format("%.2s/20%.2s", &m_Expiry[2], m_Expiry );


   	//Track1 Data (m_CardHolderName)
   	m_CardHolderName[0]='\0';
  	if( GetDataElement( TAG_CarHolNam, ucDataValue, &Length) != ACCESS_OK ) return FALSE;
	if( Length!=0) 
	{
		if (Length>24) Length=24;
		memcpy( m_CardHolderName, ucDataValue, Length );
		m_CardHolderName[Length]='\0';
	}
	
	//if( !ExamineCard( m_CardNumber ) )
	//{
	//	return EXTRACT_ERROR;
	//}

	//if( BinTableNo != DOMBIN6 && BinTableNo != DOMBINRANGE )
	//{
	//	BinAvailTXTypes=T_PURCHASE|T_CASH|T_VOID;
	//}
	

	if( GetCardBrand()!= BRAND_VISA ) 
	{
		m_EMVCardTags.t9F53[0] = 1;
		m_EMVCardTags.t9F53[1] = 0x52;
	}



	return PROCESS_OK;
}


BYTE CMainFrame::GetPin( BYTE UseMAC, LPBYTE PinBl ,BYTE PlainFlag )
{
	// Virtual Function
	BYTE Len,PANBlock[16],PINBlock[16],Tmp[17],PIN[17];
	BYTE PinLength;
	BYTE ClearKeyReg[16],Count,CardPart[13];

	CPinPad PinPad;

	WriteLogFile("GetPin","Start Function");

	m_NoPinPad = FALSE;

	Len = (BYTE)strlen( (const char*)m_CardNumber );

	if( Len>22 ) Len=22;
	if( !Len ) Len=1;
	Count=12;
	memset( CardPart, '0', 12 );
	Len--;
	while (Len-- && Count--) 
	{
		CardPart[Count] = m_CardNumber[Len];
	}

	CardPart[12]='\0';

	memcpy(PANBlock,"0000",4);
	memcpy(PANBlock+4,CardPart,12);
	
	PinLength=12;
	
	memset(PIN,'\0',PinLength);

	//**********************************************
	//					PIN PAD
	if( PinPad.DoModal() == IDOK )
	{
		PinLength = PinPad.Pin.GetLength();
		memcpy(PIN, PinPad.Pin.GetBuffer(), PinLength);
	}
	else
	{
		DisplayMessage(3, "PIN BY PASS", TRUE);
		return FALSE;
	}
	//**********************************************



	////////////////////////////////////////////
	//DisplayMessage( "FAKE PIN: 1234" );
	//memcpy(PIN, "1234", 4);	// fake pin - @ferhat
	//PinLength = 4;
	////////////////////////////////////////////

	Len = PinLength;

	while( PIN[--Len]==' ' );

	Len++;

	if( Len<4 ) 
	{
		return FALSE;
	}

	PinLength=Len;

	if( PlainFlag ) 
	{
		memcpy(PinBl,PIN,PinLength);
		PinBl[PinLength]='\0';
	}
	else 
	{
		sprintf( (char*)Tmp, "%02X", (WORD)Len );
		memcpy( Tmp+2, PIN, Len );
		memset( Tmp+2+Len, 'F', 14-Len );
		XOR( Tmp, PANBlock, PINBlock );
		CDEA::Decrypt( m_MasterKey, m_InsKey, ClearKeyReg );
		CDEA::Encrypt( ClearKeyReg, PINBlock, PinBl );
	}
	return TRUE;


}

void CMainFrame::XOR( LPBYTE B1, LPBYTE B2, LPBYTE Result )
{
	BYTE Len, x1, x2, dummy[2];
	Len=16;
	while (Len--) 
	{
		x1=(*B1)%16;       // A->65%16 = 1 
		if (*B1>'9') x1+=9;
		x2=(*B2)%16;
		if (*B2>'9') x2+=9;
		sprintf((char *)dummy,"%X",(USHORT)(x1^x2));
		*Result=dummy[0];
		B1++;
		B2++;
		Result++;
	}
}


BYTE CMainFrame::FillTermParams( void )
{
	ULONG TmpLong;
	UCHAR *Ptr;
	
	// Application AIDs
	m_ApplicationList[0]=18*7;
	memcpy(&m_ApplicationList[1],	"\x07\xA0\x00\x00\x00\x03\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
									"\x07\xA0\x00\x00\x00\x03\x20\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
									"\x07\xA0\x00\x00\x00\x04\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
									"\x07\xA0\x00\x00\x00\x04\x30\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
									"\x07\xA0\x00\x00\x00\x04\x40\x60\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
									"\x07\xA0\x00\x00\x00\x10\x10\x30\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" 
									"\x07\xA0\x00\x00\x00\x04\x10\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", /*MetroBank VocaLink Link application*/
									m_ApplicationList[0] );


	m_NumOfRevokeKey = 0;

// Static Tags
	m_EMVTermTags.t9F40[0] = 0x05;
	m_EMVTermTags.t9F40[1] = 0xE0;
	m_EMVTermTags.t9F40[2] = 0x00;
	m_EMVTermTags.t9F40[3] = 0xF0;
	m_EMVTermTags.t9F40[4] = 0xE0;
	m_EMVTermTags.t9F40[5] = 0x01;

	m_EMVTermTags.t9F33[0] = 0x03;
	m_EMVTermTags.t9F33[1] = 0x20;	// bit 6: 1 = IC with contacts
//	m_EMVTermTags.t9F33[1] = 0xE0;
//	m_EMVTermTags.t9F33[2] = 0x20;	// bit 6: 1 = Signature (paper)
	m_EMVTermTags.t9F33[2] = 0xF0;
	m_EMVTermTags.t9F33[3] = 0xC0;	// bit 8: 1 = Offline static data authentication
									// bit 7: 1 = Offline dynamic data authentication


	m_EMVTermTags.t9F35[0] = 0x01;
	m_EMVTermTags.t9F35[1] = 0x22;
	
	
	m_EMVTermTags.t9F1C[0] = 0x04;
	Pack(BASEHEX,(UCHAR*)"00009000",&m_EMVTermTags.t9F1C[1],8); //TerminalID
	
   
	memcpy(m_EMVTermTags.tDF83,"\x05\xFC\x50\xAC\xA0\x00",6); //TACDefault
	memcpy(m_EMVTermTags.tDF84,"\x05\x04\x00\x00\x00\x00",6); //TACDenial
	memcpy(m_EMVTermTags.tDF85,"\x05\xF8\x50\xAC\xF8\x00",6);// TACOnline

	memcpy(&TmpLong,"\x00\x00\x00\x00",4);	//RndSelLimit

	TmpLong*=100;

	Ptr=(UCHAR*)&TmpLong;
	
	m_EMVTermTags.tDF87[0]='\x06'; //RndSelLimit
	m_EMVTermTags.tDF87[3]=*(Ptr+3);
	m_EMVTermTags.tDF87[4]=*(Ptr+2);
	m_EMVTermTags.tDF87[5]=*(Ptr+1);
	m_EMVTermTags.tDF87[6]=*Ptr;
	

	memcpy(m_EMVTermTags.tDF88,"\x00\x00",2); //RndSelPercent
	memcpy(m_EMVTermTags.tDF89,"\x00\x00",2); //MaxRndSelPercent
	memcpy(m_EMVTermTags.tDF95,"\x0B\x9F\x37\x04\x9F\x47\x01\x8F\x01\x9F\x32\x01",0x0B+1); //DefaultDDOL
	memcpy(m_EMVTermTags.tDF98,"\x03\x9F\x08\x02",0x03+1); //DefaultTDOL
	memcpy(m_EMVTermTags.tDFA0,"\x00\x00",0x00+1); //OnlineDOL
	memcpy(m_EMVTermTags.t5F2A,"\x02\x09\x78",3); //CurrencyCode
	memcpy(m_EMVTermTags.t9F1A,"\x02\x07\x92",3); //CountryCode

//	if (atoi(S.CurTXType)==1 || atoi(S.CurTXType)==40)
//		TmpLong=0L;
//	else 	
		memcpy(&TmpLong,"\xFF\xFF\xFF\xFF",4); //FloorLimit

	TmpLong*=100;

	Ptr=(UCHAR*)&TmpLong;
	
	m_EMVTermTags.t9F1B[0]=0x04; //FloorLimit
	m_EMVTermTags.t9F1B[1]=*(Ptr+3);
	m_EMVTermTags.t9F1B[2]=*(Ptr+2);
	m_EMVTermTags.t9F1B[3]=*(Ptr+1);
	m_EMVTermTags.t9F1B[4]=*Ptr;

	
   
   	m_EMVTermTags.t9F1E[0]=6;

	GetSerialNumber(&m_EMVTermTags.t9F1E[1]);

	return PROCESS_OK;
}

BYTE CMainFrame::GetTxType( void )
{
	// Virtual Function
	if( m_CurTXType[0]=='3' ) return 1; // SALE and/or CASH
	
	return 0;
}

BYTE CMainFrame::SplitSale( LPBYTE PCardNumber, LPDWORD pxTotAmount )
{
	// Virtual Function
	*pxTotAmount = 0; 
	return PROCESS_OK;
}

void CMainFrame::GetOnlineTags( LPBYTE OnlineTags )
{
	// Virtual Function
	memcpy( OnlineTags, "\x19\x9F\x26\x08\x95\x05\x9F\x33\x03\x9F\x36\x02\x82"
						"\x02\x9F\x37\x04\x9F\x34\x03\x9F\x10\x00\x9F\x27\x01", 26 );
}

BYTE CMainFrame::GetBankDecision( void )
{
	// Virtual Function
	DisplayMessage(2, "GET ONLINE FAKE AUTHORIZATION", TRUE );

	UCHAR TempStr[10];
	if( m_T.Amount > 100000 )
		sprintf( (char*)TempStr, "8A023939" );	//Authorisation Response Code - 99
	else
		sprintf( (char*)TempStr, "8A023030" );	//Authorisation Response Code - 00
	
	m_EMVDataRcvLen=4;
	Str2Bcd( (char*)TempStr, 8, 0, m_EMVDataRcv, m_EMVDataRcvLen, 0 );

	return PROCESS_OK;
}

BYTE CMainFrame::InputAmount( ULONG &Amount )
{
	CInputAmount InpAmount;
	Amount = 0;
	if( InpAmount.DoModal() == IDOK )
	{
		m_strAmount = InpAmount.strAmount;
		DisplayMessage(1, "AMOUNT: " + m_strAmount, TRUE );
		Amount = InpAmount.Amount;
		m_T.Amount = Amount;
		return PROCESS_OK;
	}
	else
	{
		return GET_AMOUNT_ABORT;
	}

	return PROCESS_OK;
}


LONG CMainFrame::OnReaderMessage(WPARAM wParam, LPARAM dummy)
{
	OnReaderMessage((CSmartCardReader*) wParam);
	return 0L;
}

void CMainFrame::OnReaderMessage(CSmartCardReader* pReader)
{
	Lock();
	OnReaderMessageEx(pReader);
	Unlock();
}

void CMainFrame::OnReaderMessageEx(CSmartCardReader* pReader)
{
	m_bReady = TRUE;
	SCARD_READERSTATE readerStatus;
	if (pReader->GetReaderStatus(&readerStatus) != SCARD_S_SUCCESS) return;
	DWORD dwStatus = readerStatus.dwEventState;
	if (dwStatus & SCARD_STATE_EMPTY) {
		OnRemoveCard(pReader);
	}
	else if (dwStatus & SCARD_STATE_PRESENT) {
		OnInsertCard(pReader , &readerStatus);
	}
}


void CMainFrame::OnInsertCard(CSmartCardReader* pReader, LPSCARD_READERSTATE pReaderState)
{
	m_wndStatusBar.SetWindowText( "Card Inserted, Transaction Started." );

	long lRes = pReader->ConnectToCard(&m_card);
	if (lRes != SCARD_S_SUCCESS) 
	{
		AfxMessageBox(GetSCardErrorMessage(lRes));
		return;
	}

	m_card.SetATR(pReaderState->rgbAtr, pReaderState->cbAtr);

	m_protocol = 0;
	if (!memcmp(m_card.GetIoRequest(),SCARD_PCI_T1,sizeof(SCARD_IO_REQUEST))) 
	{
		m_protocol = 1;
	}


	if(m_card.ColdReset() != SCARD_S_SUCCESS){
		AfxMessageBox("Can not reset card!");
		return;
	}

	BYTE tmpBuf[1024];
	DWORD rcvLen = 512;
	CString tmp;

	VS_UnPack(tmpBuf, m_card.GetATR() , m_card.GetATRLen() );
	tmp = CString((char*)tmpBuf, m_card.GetATRLen() * 2);


	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);

	pFrame->cntSmartTransList.InsertItem(0,"Cold Reset...");
	pFrame->cntSmartTransList.SetItemText(0,1, "ATR: " + tmp );

	memset( m_CurTXType, 0, 3 );

	switch( pFrame->cntTransType.GetCurSel() )
	{
		case 0:
			memcpy( m_CurTXType, "10", 2 );	// SALE 
			m_strTranType = "100"; // ISO 8583
			break;
		case 1:
			memcpy( m_CurTXType, "30", 2 ); // CASH
			m_strTranType = "100"; // ISO 8583
			break;
		case 2:
			memcpy( m_CurTXType, "40", 2 ); // MAIL ORDER
			m_strTranType = "100"; // ISO 8583
			break;
		case 3:
			memcpy( m_CurTXType, "60", 2 ); // REVERSE
			m_strTranType = "420"; // ISO 8583
			break;
		default:
			memcpy( m_CurTXType, "10", 2 );
			m_strTranType = "100"; // ISO 8583
			break;
	}

	WriteSmartLogFile( "START OF TRANSACTION" );
	WriteLogFile( "******************START OF TRANSACTION******************" );

	if( EMVTransaction()==PROCESS_OK )
	{
		if( m_IsApproved )
		{
			m_wndStatusBar.SetWindowText( "Transaction Approved. Remove Card." );
			WriteSmartLogFile( "END OF TRANSACTION - APPROVED" );
			WriteLogFile( "TRANSACTION APPROVED" );
			DisplayMessage(1, "TRANSACTION APPROVED", TRUE );
			DisplayMessage(3, "REMOVE YOUR CARD", FALSE );
		}
	}

	if( !m_IsApproved )
	{
		m_wndStatusBar.SetWindowText( "Transaction Declined. Remove Card." );
		WriteSmartLogFile( "END OF TRANSACTION - DECLINED" );
		WriteLogFile( "TRANSACTION DECLINED" );
		DisplayMessage(1, "TRANSACTION DECLINED", TRUE );
	}
	
	WriteTagLogFile();
	WriteLogFile( "*******************END OF TRANSACTION*******************" );




}

void CMainFrame::OnRemoveCard(CSmartCardReader* pReader)
{
	m_wndStatusBar.SetWindowText( "Virtual POS is Ready." );

	DisplayMessage(1, "PLESE INSERT YOUR CARD", TRUE );
	m_card.Disconnect();
	pReader->SetCardInReader(NULL);
}

BYTE CMainFrame::SendSmartData(WORD SendLen, LPBYTE CardSendData, WORD &OutLen, LPBYTE CardReplyData)
{
	CEMV::SendSmartData(SendLen, CardSendData, OutLen, CardReplyData);

	BYTE tmpBuf[1024];
	DWORD rcvLen = 512;
	CString tmp,tmp2;

	VS_UnPack(tmpBuf, CardSendData, SendLen);
	tmp = CString((char*)tmpBuf, SendLen * 2);
	tmp2.Format( "(%02XH)", SendLen);

	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);

	pFrame->cntSmartTransList.InsertItem(0,tmp2+tmp);

	tmp2.Format( "SMARTIN (%02XH) ", SendLen);
	WriteLogFile(SendLen, CardSendData);


	long lRes = m_card.Transaction(CardSendData, SendLen, CardReplyData, rcvLen);
	if (lRes != SCARD_S_SUCCESS) 
	{
		tmp = "";
		tmp += CString(GetSCardErrorMessage(lRes));
		tmp += "";
	
		pFrame->cntSmartTransList.SetItemText(0,1, tmp);

		return CARD_COM_ERROR;
	}

	VS_UnPack(tmpBuf, CardReplyData, rcvLen);
	tmp = CString((char*)tmpBuf, rcvLen * 2);
	tmp2.Format( "(%02XH)", rcvLen);
	pFrame->cntSmartTransList.SetItemText(0,1, tmp2+tmp);

	WriteLogFile(rcvLen,CardReplyData);

	OutLen = (WORD)rcvLen;

	WriteSmartLogFile( CardSendData, SendLen, CardReplyData, OutLen );
/*
	if( CardReplyData[rcvLen - 2]!=0x90 || CardReplyData[rcvLen - 1]!=0x00 ) 
	{
		switch( CardReplyData[rcvLen - 2] )
		{
			case 0x62:
				if( CardReplyData[rcvLen - 1]==0x83 )return SELECTED_FILE_INVALIDATED;
				else return CARD_ERROR;
			case 0x63:
				if( CardReplyData[rcvLen - 1]==0x00 )return AUTHENTICATION_FAILURE;
				else if( (CardReplyData[rcvLen - 1]&0xC0)==0xC0 )return VERIFICATION_FAILURE;
				else return CARD_ERROR;
			case 0x64:
				if( CardReplyData[rcvLen - 1]==0x00 )return FILE_CORRUPT;
				else return CARD_ERROR;
			case 0x65:
				if( CardReplyData[rcvLen - 1]==0x81 )return MEMORY_FAILURE;
				else return CARD_ERROR;
			case 0x67:
				if( CardReplyData[rcvLen - 1]==0x00 )return WRONG_LENGTH;
				else return CARD_ERROR;
			case 0x69:
				if( CardReplyData[rcvLen - 1]==0x81 )return FCP_PARAMETERS_INCORRECT;
				else if( CardReplyData[rcvLen - 1]==0x82 )return SECURITY_NOT_SATISFY;
				else if( CardReplyData[rcvLen - 1]==0x83 )return AUTHENTICATION_BLOCKED;
				else if( CardReplyData[rcvLen - 1]==0x85 )return CONDITION_NOT_SATISFY;
				else if( CardReplyData[rcvLen - 1]==0x86 )return COMMAND_NOT_ALLOWED;
				else return CARD_ERROR;
			case 0x6A:
				if( CardReplyData[rcvLen - 1]==0x82 )return FILE_NOT_FOUND;
				else if( CardReplyData[rcvLen - 1]==0x84 )return NOT_ENOUGH_SPACE;
				else if( CardReplyData[rcvLen - 1]==0x86 )return INCORRECT_P1P2;
				else if( CardReplyData[rcvLen - 1]==0x88 )return REFERANCE_NOT_FOUND;
				else if( CardReplyData[rcvLen - 1]==0x89 )return FILE_ALREADY_EXISTS;
				else if( CardReplyData[rcvLen - 1]==0x8A )return DF_NAME_ALREADY_EXISTS;
				else return CARD_ERROR;
			case 0x6D:
				if( CardReplyData[rcvLen - 1]==0x00 )return INS_NOT_SUPPORTED;
				else return CARD_ERROR;
			case 0x6E:
				if( CardReplyData[rcvLen - 1]==0x00 )return CLA_NOT_SUPPORTED;
				else return CARD_ERROR;
			default:
				return CARD_ERROR;
		}
	}
*/
/*
	BYTE sendData[1024];
	BYTE rcvBuf[1024];
	DWORD rcvLen = 512;

	memcpy( (void*)sendData, CardSendData+5,CardSendData[4]);

	if (m_card.ExchangeAPDU(CardSendData[0],CardSendData[1],CardSendData[2],CardSendData[3],
					        CardSendData[4],sendData, 0x08, rcvBuf, rcvLen) == FALSE) 
	{
		return FALSE;
		//return res;
	}
*/
	return PROCESS_OK;
}

BYTE CMainFrame::DisplayDebug( CString message )
{
//	cntSmartTransList.InsertItem(0,message);
	return PROCESS_OK;
}

BYTE CMainFrame::DisplayClear( void )
{
	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);
	pFrame->cntMessageBox1.SetWindowText( "" );
	pFrame->cntMessageBox2.SetWindowText( "" );
	pFrame->cntMessageBox3.SetWindowText( "" );
	return PROCESS_OK;
}

/*BYTE CMainFrame::DisplayMessage( CString message )
{
	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);
	pFrame->cntMessageBox1.SetWindowText( message );
	return PROCESS_OK;
}
*/
BYTE CMainFrame::DisplayMessage( WORD Line, CString message, BOOL ClearLines )
{
	CInfoFrame*  pFrame = (CInfoFrame*)m_wndSplitter.GetPane(0, 0);

	if( ClearLines ) DisplayClear();
	switch( Line )
	{
		case 1:
			pFrame->cntMessageBox1.SetWindowText( message );
			break;
		case 2:
			pFrame->cntMessageBox2.SetWindowText( message );
			break;
		case 3:
			pFrame->cntMessageBox3.SetWindowText( message );
			break;
		default:
			break;
	}
	return PROCESS_OK;
}


BYTE CMainFrame::AddRec( void )
{
	CTransactionView*  pView = (CTransactionView*)m_wndSplitter.GetPane(0, 1);

	CTime currDateTime = CTime::GetCurrentTime();
	CString currDate = currDateTime.Format( "%d/%m/%Y" );
	CString currTime = currDateTime.Format( "%H:%M:%S" );

	m_strResponseCode = CString( m_Approval ); 
	
	CString BatchNo, SeqNo;
	BatchNo.Format("%d", m_BatchNo);
	SeqNo.Format("%d", m_SeqNo);



	pView->AddTarnsaction(	currDate, currTime, 
							BatchNo, SeqNo, 
							m_strTranType, m_strAmount, 
							m_strCardNumber, m_strExpiry, 
							m_strResponseCode, m_strStripeData,
							"");

	m_SeqNo++;
	if( m_SeqNo>9999 ) 
	{
		m_BatchNo++;
		m_SeqNo=1;
	}
	if( m_BatchNo>999999 ) m_BatchNo=1;
	return PROCESS_OK;
}

INT CMainFrame::DisplayAppMenu( CHIPMENU *pxMenu, UCHAR ucSize )
{
	// Virtual Function
	return 0;//pxMenu[0].ucVal;
}

bool CMainFrame::WriteSmartLogFile( CString message )
{
	// Virtual Function
	CString logStr;

	CTime t = CTime::GetCurrentTime();
	CString currDateTime = t.Format( "%A, %B %d, %Y, %H:%M:%S" );
	// s == "Tuesday, March 19, 1991"

	CStdioFile logfile("VirtualPosTrace.log", CFile::modeCreate | CFile::modeNoTruncate | 
		CFile::modeReadWrite | CFile::typeText );
	if(!logfile)
	{
	  AfxMessageBox("Can not open VirtualPos.log");
	  return false;
	}
	logfile.SeekToEnd(); 

	logStr.Format("[[%s - %s]]%c<--------------------------------->%c"
																, message.GetBuffer(), currDateTime.GetBuffer()
																, 0x0A
																, 0x0A);
	logfile.Write(logStr.GetBuffer(), logStr.GetLength());

	logfile.Close();

	return true;



}
bool CMainFrame::WriteSmartLogFile( LPBYTE Input, WORD InputLen, LPBYTE Output, WORD OutputLen )
{
	// Virtual Function
	CString logStr;
	CString tmpIn,tmpOut;
	BYTE tmpBuf[1024];


	CStdioFile logfile("VirtualPosTrace.log", CFile::modeCreate | CFile::modeNoTruncate | 
		CFile::modeReadWrite | CFile::typeText );
	if(!logfile)
	{
	  AfxMessageBox("Can not open VirtualPos.log");
	  return false;
	}
	logfile.SeekToEnd(); 



	VS_UnPack( tmpBuf, Input, InputLen );
	tmpIn = CString((char*)tmpBuf, (InputLen) * 2);

	VS_UnPack( tmpBuf, Output, OutputLen );
	tmpOut = CString((char*)tmpBuf, (OutputLen) * 2);


	//logStr.Format("Input [[%s]]%c%cOutput[[%s]]%c%c<--------------------------------->%c%c"	
	//															, tmpIn.GetBuffer(), 0x0D, 0x0A
	//															, tmpOut.GetBuffer(), 0x0D, 0x0A
	//															, 0x0D, 0x0A);
	logStr.Format("Input [[%s]]%cOutput[[%s]]%c<--------------------------------->%c"	
																, tmpIn.GetBuffer(), 0x0A
																, tmpOut.GetBuffer(), 0x0A
																, 0x0A);
	logfile.Write(logStr.GetBuffer(), logStr.GetLength());

	logfile.Close();

	return true;
}


bool CMainFrame::WriteLogFile(CString logMessage)
{
	// Virtual Function
	CString logStr;

	CTime t = CTime::GetCurrentTime();
	
	CString currDateTime = t.Format( "%A, %B %d, %Y, %H:%M:%S" );
	// s == "Tuesday, March 19, 1991"


	CStdioFile logfile("VirtualPos.log", CFile::modeCreate | CFile::modeNoTruncate | 
		CFile::modeReadWrite | CFile::typeText );
	if(!logfile)
	{
	  CWnd a; 
	  a.MessageBox("Can not open VirtualPos.log");
	  return false;
	}
	logfile.SeekToEnd(); 

	logStr.Format("[[%s]]",currDateTime.GetBuffer());
	logfile.Write(logStr.GetBuffer(), logStr.GetLength());


//	logStr.Format("[[%s]]%c%c",logMessage.GetBuffer(),0x0D,0x0A);
	logStr.Format( "[[%s]]%c", logMessage.GetBuffer() ,0x0A );
	logfile.Write(logStr.GetBuffer(), logStr.GetLength());

	logfile.Close();

	return true;
}

bool CMainFrame::WriteLogFile(CString title, CString logMessage)
{
	// Virtual Function
	CString logStr;


	logStr.Format("%-25.25s]][[%s", title.GetBuffer() ,logMessage.GetBuffer());

	return WriteLogFile(logStr);
}

bool CMainFrame::WriteLogFile(DWORD BuffLen, LPBYTE BuffData)
{
	// Virtual Function
	CString logStr,tmp;
	BYTE tmpBuf[1024];


	VS_UnPack(tmpBuf, BuffData, BuffLen);
	tmp = CString((char*)tmpBuf, BuffLen * 2);


	logStr.Format("PACKED LEN %02XH]][[%s", BuffLen ,tmp.GetBuffer());

	return WriteLogFile(logStr);
}


bool CMainFrame::WriteLogFile(CString title, DWORD index, CString logMessage)
{
	// Virtual Function
	CString logStr;


	logStr.Format("%-25.25s]][[INDEX %-6d]][[%s", title.GetBuffer(), index, logMessage.GetBuffer());

	return WriteLogFile(logStr);
}

bool CMainFrame::WriteLogFile(CString title, const BYTE Tag[2], LPBYTE Address)
{
	// Virtual Function
	CString logStr,tmp;
	BYTE tmpBuf[1024];


	VS_UnPack(tmpBuf, Address, Address[0]+1);
	tmp = CString((char*)tmpBuf, (Address[0]+1) * 2);


	if(Tag[1]==0x00)
		logStr.Format("%-25.25s]][[TAG %02X  ]][[%s", title.GetBuffer(), Tag[0], tmp.GetBuffer());
	else
		logStr.Format("%-25.25s]][[TAG %02X%02X]][[%s", title.GetBuffer(), Tag[0], Tag[1], tmp.GetBuffer());

	return WriteLogFile(logStr);
}

bool CMainFrame::WriteTagLogFile( void )
{
	// Virtual Function
	CString logStr,Refer,tmp;
	BYTE tmpBuf[1024];

	CTime t = CTime::GetCurrentTime();
	CString currDateTime = t.Format( "%A, %B %d, %Y, %H:%M:%S" );
	// s == "Tuesday, March 19, 1991"

	CStdioFile logfile("VirtualPosTransactionTags.log", CFile::modeCreate | CFile::modeNoTruncate | 
		CFile::modeReadWrite | CFile::typeText );
	if(!logfile)
	{
	  AfxMessageBox("Can not open VirtualPosTransactionTags.log");
	  return false;
	}
	logfile.SeekToEnd(); 

	logStr.Format( "%cTRANSACTION TAG LIST%c%s%c<--------------------------------->%c", 0x0A, 0x0A, currDateTime.GetBuffer() ,0x0A ,0x0A );
	logfile.Write( logStr.GetBuffer(), logStr.GetLength() );


	for( WORD i=0; i<MAX_TAG_COUNT; i++ )
	{
		if( m_TagAddress[i].Address[0]>0 )
		{
			VS_UnPack(tmpBuf, &m_TagAddress[i].Address[1], m_TagAddress[i].Address[0]);
			tmp = CString((char*)tmpBuf, (m_TagAddress[i].Address[0]) * 2);

			if( m_TagAddress[i].ucSource == 'C' ) Refer = "CARD ";
			else if( m_TagAddress[i].ucSource == 'T' ) Refer = "TERM ";
			else Refer = "ISSU ";

			logfile.Write( Refer.GetBuffer(), Refer.GetLength() );

			if( m_TagAddress[i].Tag[1]==0x00 )
			{
				logStr.Format("TAG %02X   - %-60s [[%s]]"	, m_TagAddress[i].Tag[0] 
															, m_TagAddress[i].Description
															, tmp.GetBuffer() );
			}
			else
			{
				logStr.Format("TAG %02X%02X - %-60s [[%s]]"	,m_TagAddress[i].Tag[0], m_TagAddress[i].Tag[1] 
															, m_TagAddress[i].Description
															, tmp.GetBuffer() );
			}

			logfile.Write( logStr.GetBuffer(), logStr.GetLength() );

			switch( m_TagAddress[i].ucFormat )
			{
				case 	ANS:
					logStr.Format("(ANS)~%s~%c", &m_TagAddress[i].Address[1], 0x0A );
					break;
				case	ANU:
					logStr.Format("(ANU)~%s~%c", &m_TagAddress[i].Address[1], 0x0A );
					break;
				case	NUM:
					logStr.Format("(NUM)%c", 0x0A );
				case	CNU:
					logStr.Format("(CNU)%c", 0x0A );
				case	BIN:
					logStr.Format("(BIN)%c", 0x0A );
				case	HEX:
					logStr.Format("(HEX)%c", 0x0A );
			}

			logfile.Write( logStr.GetBuffer(), logStr.GetLength() );

		}

	}


	logfile.Close();

	return true;
}






void CMainFrame::OnVirtualPosSetting()
{
	// TODO: Add your command handler code here
	CVirtualPosSetting dlg;
	dlg.DoModal();
}
